훌륭한 접근입니다. 이제 명확하게 정의된 최신 `blueprint.md`를 '설계상의 목표'로 삼고, 현재 시스템의 구현 상태를 비교 분석하여 잠재적인 문제점과 보완 필요 사항을 체계적으로 탐색해 보겠습니다.

이전 논의에서 제기했던 내용들을 포함하여, 청사진의 원칙을 기준으로 더욱 심층적인 분석을 진행하겠습니다.

---

### **Blueprint 기준 시스템 보완점 분석**

새로운 청사진은 시스템의 이상적인 상태를 명확히 정의합니다. 이 이상과 현실 사이의 간극을 메우기 위한 몇 가지 구체적인 보완점을 제안합니다.

#### **카테고리 1: 철학-구현 간의 잠재적 충돌 해소**

Blueprint에 명시된 핵심 철학이 특정 시나리오에서 오작동하거나 모순을 일으킬 수 있는 지점들입니다.

##### **1.1. '환경별 역할 분담' 원칙의 충돌**

*   **현상**:
    *   **Recipe (논리)**: `recipes/.../random_forest_classifier.yaml`는 `augmenter.type: feature_store`를 통해 "피처 스토어 사용"이라는 **논리적 요구사항**을 명시합니다.
    *   **Config (인프라)**: `config/local.yaml`은 `feature_store.provider: passthrough`를 통해 "피처 스토어 비활성화"라는 **인프라 제약**을 설정합니다.

*   **Blueprint 원칙과의 관계**: 이는 "환경별 역할 분담" 철학의 핵심적인 시나리오이지만, 현재 구조에서는 두 설정이 충돌하여 파이프라인 실패로 이어질 가능성이 높습니다. 청사진은 "환경에 따라 차등적으로 동작"해야 한다고 말하지만, 현재는 '동작'이 아닌 '충돌'이 발생합니다.

*   **잠재적 문제점**: 로컬 환경에서 피처 스토어를 사용하는 레시피를 실행하면, `Augmenter`가 피처를 가져오지 못해 오류가 발생합니다. 개발자는 매번 로컬 테스트를 위해 레시피의 `augmenter` 섹션을 수동으로 주석 처리해야 하는 불편함이 생깁니다.

*   **보완 제안 (지능형 Augmenter)**:
    1.  `Augmenter` 컴포넌트(`src/components/_augmenter/`)를 수정하여, **실행 시점의 `config` 설정을 우선**하도록 만듭니다.
    2.  만약 `config`의 `provider`가 `passthrough`이면, 레시피에 `augmenter` 설정이 있더라도 이를 무시하고, "로컬 환경 설정에 따라 피처 증강을 건너뜁니다." 라는 경고(warning) 로그만 남긴 후 원본 데이터를 그대로 반환하도록 로직을 변경합니다.
    3.  이를 통해 레시피 수정 없이도 모든 환경에서 코드가 오류 없이 '의도대로' 차등적으로 동작하게 됩니다.

##### **1.2. '선언적 파이프라인'의 모호함**

*   **현상**:
    *   **Recipe**: `source_uri`에 `my_query.sql` 파일을 지정하여 SQL 기반 데이터 로딩을 선언합니다.
    *   **Config**: `config/local.yaml`은 `data_adapters.default_loader`를 `storage`로 지정합니다.

*   **Blueprint 원칙과의 관계**: "선언적 파이프라인" 원칙은 사용자가 선언만 하면 시스템이 알아서 동작해야 함을 의미합니다. 하지만 현재는 `Factory`가 `SQLAdapter`와 `StorageAdapter` 중 무엇을 선택할지에 대한 규칙이 코드 내부에 숨겨져 있어 명시적이지 않습니다.

*   **잠재적 문제점**: 개발자는 `default_loader` 설정이 우선인지, `source_uri`의 확장자가 우선인지 알기 어렵습니다. 이러한 '암묵적인 마법'은 예측 불가능한 동작과 디버깅의 어려움을 초래할 수 있습니다.

*   **보완 제안 (명시성 강화)**:
    1.  `config/local.yaml`의 `default_loader` 설정을 제거합니다.
    2.  대신, 레시피의 `loader` 섹션에 `adapter_type: sql` 또는 `adapter_type: storage` 와 같이 **어댑터 타입을 명시적으로 선언**하도록 구조를 변경합니다.
    3.  `Factory`는 이 `adapter_type`을 유일한 기준으로 삼아 어댑터를 생성하도록 단순화합니다. 이를 통해 모호함이 사라지고 레시피만 봐도 데이터 로딩 방식이 명확히 이해됩니다.

#### **카테고리 2: 사용자 경험 및 명확성 강화**

시스템은 동작하지만, 사용자 입장에서 혼란스럽거나 불편할 수 있는 지점들입니다.

##### **2.1. 하이퍼파라미터 설정의 우선순위 불분명**

*   **현상**: 튜닝 관련 설정(`enabled`, `timeout` 등)이 `config`와 `recipe` 양쪽에 존재합니다.

*   **Blueprint 원칙과의 관계**: 이는 "설정과 논리의 분리" 철학을 잘 따르는 훌륭한 설계이지만, 두 설정이 충돌할 경우 어떤 것이 우선되는지에 대한 규칙이 사용자에게 명확히 전달되지 않습니다.

*   **잠재적 문제점**: 사용자가 레시피에 `hyperparameter_tuning.enabled: true`를 설정하고도 `config` 설정 때문에 튜닝이 실행되지 않는 이유를 파악하기 어렵습니다.

*   **보완 제안 (실행 시점 로그 강화)**:
    1.  `Trainer` 컴포넌트(`src/components/_trainer/_trainer.py`)의 시작 부분에, 설정 병합 결과를 명시적으로 알려주는 로그를 추가합니다.
    2.  예: `INFO: 'config/local.yaml' 설정에 따라 하이퍼파라미터 튜닝이 비활성화되었습니다.` 와 같은 메시지를 출력하여, 최종적으로 적용되는 동작을 사용자가 명확히 인지할 수 있게 합니다.

##### **2.2. 학습 과정의 불투명성**

*   **현상**: `Optuna`를 이용한 하이퍼파라미터 튜닝이 시작되면, 수십 분 동안 터미널에 아무런 로그가 남지 않을 수 있습니다.

*   **Blueprint 원칙과의 관계**: 청사진은 개발자 경험을 강조하지만, 긴 시간 동안 피드백이 없는 것은 좋은 경험이 아닙니다.

*   **잠재적 문제점**: 사용자는 시스템이 정상 동작하는지, 멈춘 것인지 알 수 없어 답답함을 느끼고 프로세스를 강제 종료할 수 있습니다.

*   **보완 제안 (Optuna 콜백 연동)**:
    1.  `Optuna`는 `study.optimize` 메서드에 `callbacks` 인자를 전달할 수 있습니다.
    2.  매 trial이 끝날 때마다 "Trial 5/50 완료. 점수: 0.85. 최고 점수: 0.87" 과 같은 로그를 출력하는 간단한 콜백 함수를 구현하여 `Trainer`에 추가합니다. 이를 통해 사용자는 진행 상황을 실시간으로 파악할 수 있습니다.

#### **카테고리 3: 시스템 견고성 및 확장성**

현재는 문제가 없지만, 시스템이 더 복잡해지고 성장함에 따라 문제가 될 수 있는 지점들입니다.

##### **3.1. 레시피 유효성 검증 시점**

*   **현상**: `validate` CLI 명령어가 있지만, 레시피의 논리적 모순까지는 검증하지 못할 수 있습니다. 대부분의 오류는 `train` 명령 실행 후, 실제 파이프라인이 동작하는 도중에 발견됩니다.

*   **Blueprint 원칙과의 관계**: 견고한 시스템은 잘못된 실행을 최대한 빨리, 가벼운 단계에서 차단해야 합니다.

*   **잠재적 문제점**: 간단한 레시피 오타나 논리적 비호환성(예: 회귀 모델에 분류 평가지표 사용)을 확인하기 위해 몇 분간 데이터 로딩과 전처리를 실행하는 것은 비효율적입니다.

*   **보완 제안 (사전 검증 강화)**:
    1.  `Settings` Pydantic 모델에 `cross-validation` 로직을 추가합니다. 예를 들어, `model.data_interface.task_type`이 `classification`이면, `evaluation.metrics`에 `roc_auc`은 올 수 있지만 `mse`는 올 수 없다는 규칙을 검증 로직으로 구현합니다.
    2.  이 검증 로직은 `load_settings_by_file` 함수 가장 마지막에 수행되어, `train` 실행 초기에 논리적 오류를 즉시 발견하고 실패시키도록 합니다.

##### **3.2. 아티팩트의 환경 종속성**

*   **현상**: `PyfuncWrapper`는 '순수 로직의 캡슐'이지만, 이 로직을 실행하는 패키지(sklearn, pandas 등)의 버전은 아티팩트 외부에, 즉 실행 환경에 의존합니다.

*   **Blueprint 원칙과의 관계**: "완전한 재현성"을 추구하는 청사진의 목표에 도달하기 위한 마지막 퍼즐입니다.

*   **잠재적 문제점**: 모델을 학습시킨 환경과 서빙하는 환경의 `scikit-learn` 버전이 다를 경우, `pickle` 로딩 오류나 미묘한 예측 결과 차이가 발생할 수 있습니다.

*   **보완 제안 (MLflow 내장 기능 활용)**:
    1.  `mlflow.pyfunc.log_model` 함수는 `conda_env`나 `pip_requirements` 인자를 통해 아티팩트와 함께 패키지 의존성을 함께 저장하는 강력한 기능을 제공합니다.
    2.  `run_training` 파이프라인 마지막에, 현재 `uv.lock` 파일의 내용을 기반으로 `pip_requirements.txt`를 동적으로 생성하여 이 인자에 전달하는 로직을 추가합니다. MLflow는 이 정보를 모델 아티팩트 내에 저장하여, 추후 이 모델을 로드할 때 정확한 버전의 환경을 재구성하도록 도와줍니다.